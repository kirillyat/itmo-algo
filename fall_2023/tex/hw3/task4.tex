\section*{Задание 4}



(a) Для слияния k отсортированных массивов можно использовать heapq.merge из модуля heapq. Эта функция позволяет сливать несколько отсортированных итерируемых объектов в один отсортированный итератор.
\begin{verbatim}
import heapq

def merge_k_sorted_arrays(arrays):
    # Создаем кучу для хранения текущих минимальных элементов
    min_heap = []
    
    # Заполняем кучу из первых элементов входных массивов
    for i, arr in enumerate(arrays):
        if arr:
            heapq.heappush(min_heap, (arr[0], i, 0))
    
    merged = []
    while min_heap:
        val, arr_idx, idx = heapq.heappop(min_heap)
        merged.append(val)
        
        if idx + 1 < len(arrays[arr_idx]):
            # Если текущий входной массив еще не закончился, добавляем следующий элемент из него в кучу
            heapq.heappush(min_heap, (arrays[arr_idx][idx + 1], arr_idx, idx + 1))
    
    return merged
\end{verbatim}

(b) Время работы сортировки слиянием, разбивающей каждый раз массив на k частей, можно оценить так:

На каждом уровне рекурсии мы разбиваем массив на k частей, что требует времени O(n) для создания каждой из них. Количество уровней рекурсии будет logk n.

На каждом уровне рекурсии происходит k слияний, каждое из которых работает за O(n), так как необходимо пройти через все элементы сливаемых массивов.

Таким образом, общее время работы сортировки слиянием, разбивающей каждый раз массив на k частей, составляет O(k logk n).
