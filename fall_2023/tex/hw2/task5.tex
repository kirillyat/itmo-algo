
\section*{Задание 5}


(a) Без ограничений на дополнительную память:

Для решения данной задачи без ограничений на дополнительную память будем использовать алгоритм Кадана.
\begin{enumerate}
\item Инициализируем две переменные: maxsum, которая будет хранить максимальную сумму подотрезка, и currentsum, которая будет хранить текущую сумму подотрезка. Обе переменные устанавливаем равными первому элементу массива.
\item Проходим по массиву, начиная со второго элемента.
\item Для каждого элемента, сравниваем текущий элемент с суммой текущего подотрезка. Если текущий элемент больше суммы, то обновляем текущую сумму, иначе оставляем текущую сумму без изменений.
\item Проверяем, если текущая сумма больше максимальной суммы, то обновляем максимальную сумму.
\item Повторяем шаги 3-4 для всех элементов массива.
\item В конце, возвращаем максимальную сумму.
\end{enumerate}

\begin{lstlisting}
def max_subarray_sum(arr):
	max_sum = arr[0]
	current_sum = arr[0]

	for i in range(1, len(arr)):
		current_sum = max(arr[i], current_sum + arr[i])
		max_sum = max(max_sum, current_sum)

	return max_sum

array = [1, -2, 3, 4, -1, 2, 1, -5, 4]
max_sum = max_subarray_sum(array)
print(max_sum)
\end{lstlisting}
	
(b) Имея возможность завести не более одного массива целых чисел длины n плюс O(1) памяти:

Для решения этой задачи с ограничением на память модифицируем алгоритмом Кадана, так чтобы он хранил только начальную и конечную позиции максимального подотрезка.
\begin{enumerate}
\item Инициализируем переменные maxsum, currentsum, startpos, endpos, которые будут хранить максимальную сумму подотрезка, текущую сумму подотрезка, начальную позицию максимального подотрезка и конечную позицию максимального подотрезка соответственно. Все переменные устанавливаем равными первому элементу массива.
\item Проходим по массиву, начиная со второго элемента.
\item Для каждого элемента, сравниваем текущий элемент с суммой текущего подотрезка. Если текущий элемент больше суммы, то обновляем текущую сумму и начальную позицию подотрезка, иначе оставляем текущую сумму и начальную позицию без изменений.
\item Проверяем, если текущая сумма больше максимальной суммы, то обновляем максимальную сумму и конечную позицию подотрезка.
\item Повторяем шаги 3-4 для всех элементов массива.
\item В конце, возвращаем максимальную сумму и подотрезок с помощью начальной и конечной позиции.
\end{enumerate}

\begin{lstlisting}
def max_subarray_sum(arr):
	max_sum = arr[0]
	current_sum = arr[0]
	start_pos = 0
	end_pos = 0

	for i in range(1, len(arr)):
		if arr[i] > current_sum + arr[i]:
			current_sum = arr[i]
			start_pos = i
		else:
			current_sum += arr[i]

		if current_sum > max_sum:
			max_sum = current_sum
			end_pos = i

	return max_sum, arr[start_pos:end_pos+1]
\end{lstlisting}