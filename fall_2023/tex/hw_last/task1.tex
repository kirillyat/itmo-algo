\section*{Контрпримеры для версий алгоритма поиска компонент сильной связности}

\subsection*{(a) mark в порядке $t_{\text{in}} \uparrow$ по $G$:}
Контрпример с графом:
\begin{verbatim}
    1 --> 2

TIN: 1 2
компонента будет состоять из двух вершин 1 и 2 хотя из 2 попасть в 1 невозможно

\end{verbatim}

\subsection*{(b) mark в порядке $t_{\text{out}} \uparrow$ по $G$:}
1->2->3->1
3<-4
начинаем с 4
TOUT: 4 3 2 1
в итоге получится одна компонента  что не верно по скольку в 4 из остальных вешин нет пути


\subsection*{(c) mark в порядке $t_{\text{in}} \downarrow$ по $G$:}
Контрпример с графом:
\begin{verbatim}
    1 --> 2 --> 3
          ^
          |
          4

Ошибочно будут выделенны компоненты [423] [1] 
 
\end{verbatim}

\subsection*{(d) mark в порядке $t_{\text{out}} \downarrow$ по $G$:}
Для этой стратегии контрпример отсутствует, так как она корректна.

\subsection*{(e) mark в порядке $t_{\text{in}} \uparrow$ по $G^\text{rev}$:}
Контрпример с графом:
\begin{verbatim}
    1 <-- 2 <-- 3
    ^           |
    |           v
    6 --> 5 --> 4
\end{verbatim}
TIN: 1 2 3 4 5 6

Ошибочно будут выделенны компоненты [1 6] [2 3] [4 5] 


\subsection*{(f) mark в порядке $t_{\text{out}} \uparrow$ по $G^\text{rev}$:}
Тот же граф, что и для (e)
TOUT: 1 2 4 3 5 6

Ошибочно будут выделенны компоненты[1 6] [2 3] [4 5 6] 


\subsection*{(g) mark в порядке $t_{\text{in}} \downarrow$ по $G^\text{rev}$:}
Контрпример с графом:
\begin{verbatim}
    1 --> 2     3 --> 4
          ^           |
          |           v
          7 <-- 6 <-- 5
TIN 7 6 5 4 3 2 1

Ошибочно будут выделенны компоненты [7 6 5 4 3] [2 1] 

\end{verbatim}
