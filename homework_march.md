### Решение

#### Часть (а) - поиск самого длинного простого пути для каждой вершины

Для нахождения самого длинного простого пути из каждой вершины мы можем использовать метод обхода в глубину (DFS). У нас есть гарантия, что исходящая степень каждой вершины равна 1, что упрощает задачу, так как из каждой вершины ведет только одно ребро. Следовательно, каждая вершина начинает только один уникальный путь, и нам необходимо лишь следовать этому пути до конца.

1. Во время DFS мы отмечаем вершины как посещенные и сохраняем для каждой вершины длину найденного пути.
2. Когда мы достигаем вершины, которая уже посещена или из которой не ведет ребра, мы возвращаемся обратно, обновляя длину пути для вершин, через которые проходим.

#### Код на Питоне:
```{python}
def dfs(graph, v, visited, lengths):
    if visited[v] or graph[v] == -1:
        return 0
    visited[v] = True
    next_v = graph[v]
    lengths[v] = 1 + dfs(graph, next_v, visited, lengths)
    return lengths[v]

def longest_paths(graph):
    n = len(graph)
    visited = [False] * n
    lengths = [0] * n
    
    for i in range(n):
        if not visited[i]:
            dfs(graph, i, visited, lengths)
    
    return lengths
```
#### Часть (∗) - O(1) запросы

Для обеспечения ответов на запросы за O(1), нам нужно предварительно обработать информацию о структуре графа. Цель - сохранить для каждой вершины конечную вершину после k шагов.

1. Мы можем модифицировать первую часть решения, чтобы также сохранять для каждой вершины, куда мы попадаем после прохождения всего пути.
2. Создаем дополнительный массив, который будет хранить эту информацию.

#### Обновленный код:
```{python}
def dfs(graph, v, visited, ends):
    if visited[v]:
        return ends[v]
    visited[v] = True
    next_v = graph[v]
    if next_v == -1:
        ends[v] = v
    else:
        ends[v] = dfs(graph, next_v, visited, ends)
    return ends[v]

def preprocess(graph):
    n = len(graph)
    visited = [False] * n
    ends = [0] * n
    
    for i in range(n):
        if not visited[i]:
            dfs(graph, i, visited, ends)
    return ends

def query(ends, v, k, graph):
    # Мы можем игнорировать k, так как изначально исходящая степень каждой вершины равна 1
    return ends[v]

# Пример использования
graph = [2, 3, 4, -1, 5, -1]  # Представление графа
ends = preprocess(graph)
v = 0; k = 10
print(query(ends, v, k, graph))  # Выведет конечную вершину для вершины v
```
Важное замечание: когда мы говорим о запросах за O(1), мы предполагаем, что предобработка уже выполнена. Предварительная обработка, конечно, занимает более чем O(1) времени, но позволяет нам выполнять после нее любое количество запросов за время O(1) для каждого.