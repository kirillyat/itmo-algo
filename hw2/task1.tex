

\begin{enumerate}

	\item Мы можем доказать амортизационную сложность этого алгоритма, используя метод потенциалов.

	\item Пусть потенциал P равен количеству единиц в битовом массиве a. 
	
	\item Изначально P=0, так как в a нет единиц.
	
	\item Предположим, что на i-м шаге цикла (где i<n) выполняется carry>0 и ai=1. 
	
	\item В этом случае, carry += ai увеличивает значение carry на 1, и carry = carry / 2 уменьшает его в два раза. Таким образом, значение carry не изменяется.
	
	\item При этом ai устанавливается в $carry \% 2$, то есть равно 1. Это означает, что на каждом шаге цикла, где carry>0 и ai=1, значение ai устанавливается в 1.
	
	\item Теперь рассмотрим следующий шаг цикла, где carry=0. В этом случае, ничего не происходит, и все остается без изменений. Внутренний цикл выполняется ровно n раз.
	
	\item Из этого следует, что для каждой единицы в a, мы увеличиваем потенциал на 1, и этого достаточно, чтобы покрыть затраты времени для всех m прибавлений единицы.
	
	\item Общее время работы операции можно оценить как время выполнения цикла плюс время на установку новых единиц в a.
	
	\item Время выполнения цикла - O(n), так как цикл выполняется ровно n раз.
	
	\item Время на установку новых единиц в a - O(m), так как у нас есть m прибавлений единицы.
	
	\item Таким образом, суммарное время работы алгоритма составляет O(n + m), что и требовалось доказать.
	
\end{enumerate}
